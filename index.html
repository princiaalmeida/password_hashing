<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Password Hashing with Salt (SHA-256) Presentation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-primary': '#0891b2', // cyan-600
              'brand-secondary': '#111827', // gray-900
              'brand-accent': '#67e8f9', // cyan-300
            },
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
              mono: ['Fira Code', 'monospace'],
            },
          },
        },
      }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
  <script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/"
  }
}
</script>
<style>
  body {
    background-color: #111827; /* gray-900 */
    overflow-x: hidden;
  }
  #matrix-bg {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
  }
  #root {
    position: relative;
    z-index: 1;
    background-color: transparent;
  }
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .fade-in {
    animation: fadeIn 0.5s ease-out forwards;
  }
</style>
<link rel="stylesheet" href="/index.css">
</head>
  <body class="font-sans">
    <canvas id="matrix-bg"></canvas>
    <div id="root"></div>
    <script>
      const canvas = document.getElementById('matrix-bg');
      const ctx = canvas.getContext('2d');

      let width = canvas.width = window.innerWidth;
      let height = canvas.height = window.innerHeight;
      let particlesArray;

      window.addEventListener('resize', () => {
          width = canvas.width = window.innerWidth;
          height = canvas.height = window.innerHeight;
          init();
      });

      class Particle {
          constructor(x, y, directionX, directionY, size, color) {
              this.x = x;
              this.y = y;
              this.directionX = directionX;
              this.directionY = directionY;
              this.size = size;
              this.color = color;
          }

          draw() {
              ctx.beginPath();
              ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
              ctx.fillStyle = '#0891b2'; // Use brand-primary color
              ctx.fill();
          }

          update() {
              if (this.x > width || this.x < 0) {
                  this.directionX = -this.directionX;
              }
              if (this.y > height || this.y < 0) {
                  this.directionY = -this.directionY;
              }
              this.x += this.directionX;
              this.y += this.directionY;
              this.draw();
          }
      }

      function init() {
          particlesArray = [];
          let numberOfParticles = (width * height) / 9000;
          for (let i = 0; i < numberOfParticles; i++) {
              let size = (Math.random() * 2) + 1;
              let x = (Math.random() * ((width - size * 2) - (size * 2)) + size * 2);
              let y = (Math.random() * ((height - size * 2) - (size * 2)) + size * 2);
              let directionX = (Math.random() * .4) - .2;
              let directionY = (Math.random() * .4) - .2;
              let color = '#0891b2';
              particlesArray.push(new Particle(x, y, directionX, directionY, size, color));
          }
      }

      function connect() {
          let opacityValue = 1;
          for (let a = 0; a < particlesArray.length; a++) {
              for (let b = a; b < particlesArray.length; b++) {
                  let distance = ((particlesArray[a].x - particlesArray[b].x) * (particlesArray[a].x - particlesArray[b].x)) +
                      ((particlesArray[a].y - particlesArray[b].y) * (particlesArray[a].y - particlesArray[b].y));
                  if (distance < (width / 7) * (height / 7)) {
                      opacityValue = 1 - (distance / 20000);
                      ctx.strokeStyle = `rgba(8, 145, 178, ${opacityValue})`; // Use brand-primary color with dynamic opacity
                      ctx.lineWidth = 1;
                      ctx.beginPath();
                      ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
                      ctx.lineTo(particlesArray[b].x, particlesArray[b].y);
                      ctx.stroke();
                  }
              }
          }
      }

      function animate() {
          requestAnimationFrame(animate);
          ctx.clearRect(0, 0, width, height);

          for (let i = 0; i < particlesArray.length; i++) {
              particlesArray[i].update();
          }
          connect();
      }

      init();
      animate();
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>